# This project makes use of the caringcaribou tool (https://github.com/CaringCaribou/caringcaribou).
# It was constructed using the module template example in caringcaribou.

# fuzzer.py
#
# This file contains a template for a simple CaringCaribou module.
# The module's entry point is the 'module_main' function.
#
# Steps to add this module to CaringCaribou and run it:
#
# 1. Copy this file to caringcaribou/tool/modules/
#      $ cp module_template.py ../modules/
#
# 2. Go to caringcaribou/tool
#      $ cd ..
#
# 3. Run the following command to run module and show usage instructions:
#      $ ./cc.py module_template -h
#

from can_actions import CanActions, int_from_str_base
from time import sleep
import argparse
import string


# Number of seconds for callback handler to be active
CALLBACK_HANDLER_DURATION = 0.0001
characters = string.hexdigits
characters = characters[0:10] + characters[16:22]
lead_id_characters = string.digits[0:8]

# --- [1]
# Methods that handle fuzzing.
# ---


# Builds a file containing fuzzing directives.
#
# @param    filename
#           The file where the fuzzing directives should be written to.
def build_fuzz_file(filename):
    return


def get_random_id():
    id = "0x" + random.choice(lead_id_characters)
    for i in range(2)
        id += random.choice(characters)
    id = int_from_str_base(id)
    return id


def get_random_payload():
    payload = ""
    for i in range(4):
        temp = "0x"
        for i in range(2):
            temp += random.choice(characters)
        payload += temp + " "
    return list_int_from_str_base(payload)


def fuzz():
    def response_handler(msg):
        ofd.write(arb_id + " Sent Message:" + send_msg + " Received Message:" + msg)

    while(True):
        id = get_random_id()
        send_msg = list_int_from_str_base("0xFF 0xFF 0xFF 0xFF")
        with CanActions(id) as can_wrap:
            can_wrap.send_single_message_with_callback(send_msg, response_handler)
            sleep(CALLBACK_HANDLER_DURATION)


# Use a given input file to send can packets, write the responses (if any) to a given output file.
#
# @param    input_filename
#           The filename of a file containing fuzzing directives as generated by build_fuzz_file.
# @param    output_filename
#           The filename of a file where the responses will be written to.
def file_fuzz(input_filename, output_filename):
    # Define a callback function which will handle incoming messages
    def response_handler(msg):
        ofd.write(arb_id + " Sent Message:" + send_msg + " Received Message:" + msg)

    ifd = open(input_filename, 'r')
    ofd = open(output_filename, "a")
    for line in ifd:
        temp = parse_line(line)
        arb_id = temp[0]
        send_msg = temp[1]
        with CanActions(arb_id) as can_wrap:
            # Send the message on the CAN bus and register a callback
            # handler for incoming messages
            can_wrap.send_single_message_with_callback(send_msg, response_handler)
            # Letting callback handler be active for CALLBACK_HANDLER_DURATION seconds
            sleep(CALLBACK_HANDLER_DURATION)


# --- [2]
# Helper methods
# ---


# Converts a given string to its list int representation.
# This string should follow a format such as: 0xFF 0xFF 0xFF 0xFF.
#
# @param    line
#           A given string thats follows the format of (for example): 0xFF 0xFF 0xFF 0xFF.
# @return   Returns a list of ints representing the values in the string.
#           For example: [0xFF, 0xFF, 0xFF, 0xFF] (with 0xFF in its int representation).
def list_int_from_str_base(line):
    temp = line.split()
    for i in range(len(temp)):
        temp[i] = int_from_str_base(temp[i])
    return temp


# Parse a given string that represents a can frame.
#
# @param    line
#           A given string thats follows the format of (for example): 0x123|0xFF 0xFF 0xFF 0xFF.
# @return   Returns a list in the following format: [id, message]
#           where id is the target device id and message is the message to be sent.
#           id and message are both in their int representation.
def parse_line(line):
    temp = list()
    pointer = line.find("|")
    temp.append(int_from_str_base(line[0: pointer]))
    temp.append(list_int_from_str_base(line[pointer + 1: len(line)]))
    return temp


def parse_args(args):
    """
    Argument parser for the template module.

    :param args: List of arguments
    :return: Argument namespace
    :rtype: argparse.Namespace
    """
    parser = argparse.ArgumentParser(prog="cc.py module_template",
                                     formatter_class=argparse.RawDescriptionHelpFormatter,
                                     description="Descriptive message for the template module",
                                     epilog="""Example usage:
                                     cc.py module_template -arbId 123
                                     cc.py module_template -arbId 0x1FF""")

    parser.add_argument("-arbId", type=str, default="0", help="arbitration ID to use")

    args = parser.parse_args(args)
    return args


# --- [3]
# Main methods.
# ---


# A simple testing method to test out caringcaribou's functionalities.
def test_module():
    arbitration_id = int_from_str_base("0x000")
    with CanActions(arbitration_id) as can_wrap:
        can_wrap.send(list_int_from_str_base("0xFF 0xFF 0xFF 0xFF"))
    line = "0x125|0xFF 0xFF 0xFF 0xF0"
    temp = parse_line(line)
    with CanActions(temp[0]) as can_wrap:
        can_wrap.send(temp[1])


# The main function of this module.
def module_main(arg_list):
    """
    Module main wrapper. This is the entry point of the module when called by cc.py

    :param arg_list: Module argument list passed by cc.py
    """
    try:
        # Parse arguments
        #args = parse_args(arg_list)
        #test_module()
        fuzz("input.txt", "output.txt")
    except KeyboardInterrupt:
        print("\n\nTerminated by user")
